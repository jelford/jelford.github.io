<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <link rel="stylesheet" type="text/css" href="/assets/style.css">
    
    <title>Working with signals in Rust - some things that signal handlers can&#x27;t handle</title>

    </head>
    <body>
    <div>
	      
    <header>
        <h1 class="breadcrumbs"><a href="/">~jelford</a> / <a href="/blog/">blog:</a></h1>
    </header>
  
    <article itemscope itemtype="http://schema.org/BlogPosting">
        <header>
        <h1 itemprop="name">Working with signals in Rust - some things that signal handlers can&#x27;t handle</h2>
            <p class="post-meta-info">
                Published on 
                <time itemprop="datePublished" datetime="2021-10-31">2021-10-31</time>. 
                <a href="https:&#x2F;&#x2F;www.jameselford.com&#x2F;blog&#x2F;working-with-signals-in-rust-pt1-whats-a-signal&#x2F;">(permalink)</a>
            </p>
        </header>
        
        <main itemprop="articleBody">
        <p>Signals are an essential part of process life-cycle on linux, but 
working with them is ... fraught - probably because it's not 
obvious that special care is needed. In this post, we'll look at what a
signal <em>is</em> and just one of the challenging aspects: restrictions on signal handlers.</p>
<span id="continue-reading"></span>
<p>TL;DR: use <a href="https://github.com/vorner/signal-hook">signal-hook</a>. There's an example at the end.</p>
<h1 id="what-s-a-signal-anyway">what's a signal anyway?</h1>
<p>There are a few ways that processes can speak to one another on a 'nix system:</p>
<ul>
<li>file-like mechanisms (network sockets, unix domain sockets, pipes, and so on)</li>
<li>IPC (either of the <a href="https://tldp.org/LDP/lpg/node21.html">System V variety</a>, 
or <a href="https://www.man7.org/linux/man-pages/man7/mq_overview.7.html">POSIX message queues</a>)</li>
<li><a href="https://www.freedesktop.org/wiki/Software/dbus/">D-Bus</a> (passing messages
via system- or session-wide buses)</li>
<li>... probably a bunch of others</li>
<li>finally: signals.</li>
</ul>
<p>Signals are probably the most primitive mechanism, and unlike the others, you
don't have to opt in somehow to receiving them. In contrast to the file-likes
(which you would have to read), or message queues (which you would have to 
poll), or D-Bus (which is built on top of sockets and you would have to 
register a handler on), signals are just sent to you: you either handle them 
or you don't. That makes signals a good fit for certain circumstances. 
Here are some examples of signals that you might have seen in the past:</p>
<ul>
<li><code>SIGSEGV</code>: invalid access to storage. This is typically sent to your process
when you access memory you shouldn't (use-after-free, or plain old bad
pointer arithmetic). If you've programmed in C, you've probably seen this.
In &quot;safe&quot; languages, with luck you can go many years without seeing one of these.</li>
<li><code>SIGINT</code>: interactive interrupt. This is typically the result of the user
hitting <code>Ctrl+C</code> on their keyboard. This is such a common interaction that
friendly runtimes will often translate it into some more palatable 
language-native form (e.g. in Python a <a href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt"><code>KeyboardInterrupt</code> is raised</a>, 
while on Java the <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Thread.html#interrupted()"><code>interrupted</code> flag</a>
is set).</li>
<li><code>SIGKILL</code>: this signal will terminate your programme, unconditionally. I
guess the clue's in the name ü§∑</li>
</ul>
<p>You can find a more complete list in <a href="https://www.man7.org/linux/man-pages/man7/signal.7.html">man 7 signal</a>.
A few signals have a default outcome if your process doesn't handle them, for
example: <code>SIGSEGV</code> or <code>SIGINT</code> will terminate your process. <code>SIGKILL</code>, on the
other hand, <em>can't</em> be handled; it will always end your process. Others might
simply be ignored.</p>
<p>Aside on Windows: Contrary to occasional internet rumours, Windows 
<a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/signal?view=msvc-160">has signal support</a>,
but it doesn't do all the same things as signals on 'nix, like:</p>
<blockquote>
<p>SIGINT is not supported for any Win32 application. When a CTRL+C interrupt
occurs, Win32 operating systems generate a new thread to specifically handle 
that interrupt. This can cause a single-thread application, such as one in 
UNIX, to become multithreaded and cause unexpected behavior.</p>
</blockquote>
<p>It also has its own mechanism for handling some of the things that are
typically done with Signals on 'nix: <a href="https://docs.microsoft.com/en-us/windows/win32/debug/structured-exception-handling">Structured Exception Handling</a>(SEH).
In my opinion, Structured Exception Handling is actually a much nicer
interface than Signals (for some of the reasons we'll see in this series) - and it fits
really well with the C++ Exceptions model that's probably most familiar to folks
outside of the C/Go/Rust space. Unlike signals, SEH uses language-level
features (<code>__try</code> / <code>__catch</code> blocks) - there's <a href="https://github.com/rust-lang/rust/issues/38963">an open issue</a>
around them in Rust, but I don't know much more than that so I'll stop there.</p>
<h1 id="how-can-i-handle-signals">how can I handle signals?</h1>
<p>So, we've got an idea of what a signal is, but how do we use them in our
application? In lots of cases, the answer is: don't. The default handlers for
signals like <code>SIGINT</code> or <code>SIGSEGV</code> will terminate your application, and in
many cases that's the right thing - e.g. in a console application, if your user
hits <code>Ctrl+C</code>, then they probably meant for your app to stop.</p>
<p>Not always though! Let's see a motivating example: let's say I have a function
that does some long-running task. If the user gets bored, I want them to be
able to terminate the process, and some message about the process not finishing.</p>
<p>Let's start with some example code:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">handle_interrupt</span><span style="color:#c0c5ce;">() {
    </span><span style="color:#65737e;">// We want this code to run if the user decided
    // to kill the process early.
    </span><span style="color:#c0c5ce;">println!(&quot;</span><span style="color:#a3be8c;">Sorry we didn&#39;t get the chance to finish</span><span style="color:#c0c5ce;">&quot;);
}

</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">() {
    println!(&quot;</span><span style="color:#a3be8c;">Hello</span><span style="color:#c0c5ce;">&quot;);

    </span><span style="color:#65737e;">// wait for some long-running job to complete
    </span><span style="color:#96b5b4;">sleep</span><span style="color:#c0c5ce;">(Duration::from_secs(</span><span style="color:#d08770;">10</span><span style="color:#c0c5ce;">)); 

    </span><span style="color:#65737e;">// I _always_ want this to run, even if the user
    // aborted the above.
    </span><span style="color:#c0c5ce;">println!(&quot;</span><span style="color:#a3be8c;">Goodbye</span><span style="color:#c0c5ce;">&quot;);
}
</span></code></pre>
<p>If the user hits <code>Ctrl+C</code> during the call to <code>sleep</code>, then we want to call
<code>handle_interrupt</code>, and then shut down via <code>&quot;Goodbye&quot;</code> (without waiting the
full 10 seconds). We can hope to achieve that with a signal handler. To start
with, we'll bring in the <a href="https://crates.io/crates/libc"><code>libc</code></a> crate. Much of
what we're talking about here is to do with the low-level interfaces provided 
by Linux, so it'll make sense to work up from there.</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">extern </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">C</span><span style="color:#c0c5ce;">&quot; </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">handle_interrupt</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">sig</span><span style="color:#c0c5ce;">: libc::c_int) { </span><span style="color:#65737e;">// 1
    </span><span style="color:#c0c5ce;">println!(&quot;</span><span style="color:#a3be8c;">Sorry we didn&#39;t get the chance to finish</span><span style="color:#c0c5ce;">&quot;);
}

</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">() {
    println!(&quot;</span><span style="color:#a3be8c;">Hello</span><span style="color:#c0c5ce;">&quot;);

    </span><span style="color:#65737e;">// All libc functions are unsafe
    </span><span style="color:#b48ead;">unsafe </span><span style="color:#c0c5ce;">{ 
        libc::signal(libc::</span><span style="color:#d08770;">SIGINT</span><span style="color:#c0c5ce;">, handle_interrupt as libc::</span><span style="color:#b48ead;">sighandler_t</span><span style="color:#c0c5ce;">); </span><span style="color:#65737e;">// 2
    </span><span style="color:#c0c5ce;">}

    std::thread::sleep(Duration::from_secs(</span><span style="color:#d08770;">10</span><span style="color:#c0c5ce;">)); 
    println!(&quot;</span><span style="color:#a3be8c;">Goodbye</span><span style="color:#c0c5ce;">&quot;);
}
</span></code></pre>
<p>You can get the raw files <a href="https://gist.github.com/jelford/d5afa01dc0f9c455d4effa4f51445d98/archive/f27eb6449beb85fc6c80b68054c1e33f06a23192.zip">here (zip)</a>.
Let's go through the changes:</p>
<ol>
<li>
<p>Our <code>handle_interrupt</code> function is going to be called from C, so it needs to
be marked <code>extern &quot;C&quot;</code>. From <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code">the Rust book</a>:</p>
<blockquote>
<p>The &quot;C&quot; part defines which application binary interface (ABI) the external function uses: the ABI defines how to call the function at the assembly level. The &quot;C&quot; ABI is the most common and follows the C programming language‚Äôs ABI.</p>
</blockquote>
<p>Our signal handler is going to be called by something <em>outside</em> of the Rust
ecosystem, so it makes sense that we have to set it up to be compatible with
the &quot;C&quot; ABI - that's the most general set of expectations for how a function
should be called.</p>
<p>While we're here, notice that the method signature has changed too. If we
take a look in <a href="https://www.man7.org/linux/man-pages/man3/signal.3p.html">man 3 signal</a>, we'll see the function signature for <code>signal</code> is:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">void (*signal(int sig, void (*func)(int)))(int);
</span></code></pre>
<p>... which is C for <code>signal</code> being a function returning an <code>int</code> that takes
two arguments:</p>
<ol>
<li>The signal number (identifying the signal for which we're installing a
handler)</li>
<li>A pointer to a function that takes a single <code>int</code> argument</li>
</ol>
<p>The (Rust) <code>libc</code> docs for <code>signal</code> don't make this terribly clear, with the
signature:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">pub unsafe extern </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">C</span><span style="color:#c0c5ce;">&quot; </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">signal</span><span style="color:#c0c5ce;">(
</span><span style="color:#c0c5ce;">   </span><span style="color:#bf616a;">signum</span><span style="color:#c0c5ce;">: c_int, 
</span><span style="color:#c0c5ce;">   </span><span style="color:#bf616a;">handler</span><span style="color:#c0c5ce;">: sighandler_t
</span><span style="color:#c0c5ce;">) -&gt; sighandler_t

</span><span style="color:#c0c5ce;">type sighandler_t = </span><span style="color:#b48ead;">size_t</span><span style="color:#c0c5ce;">;
</span></code></pre>
<p>This is most likely generated from the relevant C headers - so if you want
to take a look at the &quot;golden source&quot;, you can check <code>&lt;signal.h&gt;</code> on your
own system (most likely under <code>/usr/include/signal.h</code>).</p>
</li>
<li>
<p>This is where we actually install the signal handler. This one reads:
&quot;When this thread receives a SIGINT, run handle_interrupt&quot;. Hopefully that
one is relatively clear!</p>
</li>
</ol>
<p>So, let's run the above (the comments to the right are timings):</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">$&gt; cargo -q run
Hello                                            #  0s
^CSorry we didn&#39;t get the chance to finish       #  3s
^CSorry we didn&#39;t get the chance to finish       #  5s
^CSorry we didn&#39;t get the chance to finish       #  6s
Goodbye                                          # 10s
</span></code></pre>
<p>What we're seeing here is that we've successfully handled the interrupt: when
I press <code>Ctrl+C</code>, our signal handler is getting called, and then normal
execution resumes. Great news, right?</p>
<p>Well, not quite. There's one major issue we'd like to address: the user is
trying to terminate the process, but rather than shutting down gracefully,
as we set out to do, we're just throwing that request in the bin. We call the
signal handler, but then the <code>sleep</code> starts up again right where it left off. 
We haven't handled our signal so much as suppressed it. So we'd like to have a
way to communicate the fact that an interrupt has occurred <em>back</em> to the main 
thread of execution, wake up from our important long-running process (hey, 
sleep is important!), and shut down gracefully.</p>
<p>What we're going to see next is a brief excursion into the execution model of
signal handlers (what really happens to our thread), and then we'll look at
how we can communicate between signal handlers and application logic.</p>
<p>Brief aside: you might have noticed that <code>signal</code>'s man page <a href="https://www.man7.org/linux/man-pages/man3/signal.3p.html#APPLICATION_USAGE">says</a>:</p>
<blockquote>
<p>The sigaction() function provides a more comprehensive and
reliable mechanism for controlling signals; new applications
should use sigaction() rather than signal().</p>
</blockquote>
<p>If we were going to stick with raw <code>libc</code> calls, then it would make sense for 
us to heed this warning and use <code>sigaction</code> instead. I skipped it this time 
because the setup for it is a little more verbose - but as we're going to see,
we can leverage a library to take care of this stuff for us (and when we take 
a peek under the covers, we'll see that <code>sigaction</code> is exactly the call that 
ends up being used). It doesn't make any difference to what we're talking about
though.</p>
<h1 id="so-why-are-signals-hard-to-work-with-part-1-communicating-back-to-the-application">so why are signals hard to work with? (part 1: communicating back to the application)</h1>
<p>Okay, so we've covered signals and what they're used for, and as we've just
seen, on the face of it they're actually pretty straightforward to work with;
we just register a callback function and away we go. So why did I start off by
claiming that they're often &quot;poorly understood&quot;? Let's start by
taking a look at what's really happening with our control flow. Here's the same
code from above, but this time laid out as it would actually be
executed, in the case of a single <code>SIGINT</code> during our <code>sleep</code>:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">...
                                       ‚Üí-----------‚Üí fn handle_interrupt(...) { // 2
sleep(Duration::from_secs(10)) // 1; --‚Üë               println!(&quot;Sorry ...&quot;); 
                             ‚Üë---------------------‚Üê } // 3
println!(&quot;Goodbye&quot;);
</span></code></pre>
<p>In words, what's happening to our thread of execution is:</p>
<ol>
<li>We enter our <code>sleep</code> function</li>
<li>A signal occurs, and we execute <code>handle_interrupt</code></li>
<li>Our thread of execution returns to where it was in the <code>sleep</code> function</li>
</ol>
<p>That sounds relatively simple, but consider:</p>
<ul>
<li>We don't have any way to express that relationship to the Rust type system.
Therefore, we can't safely share state with the main logical thread of 
execution.</li>
<li>This signal-handler is <em>global</em> across our thread group. Therefore if we were
to share any state, that would lead to races</li>
<li>Most importantly, it's not guaranteed that we won't receive <em>another</em> signal
while handling the first.</li>
</ul>
<p>It's that last point that's the hardest to spot the implications of. What it
means is that anything that happens inside the signal handler must be
&quot;re-entrant&quot; - and what <em>that</em> means is that it must be safe to stop half way through and
have <em>another</em> instance of itself concurrently executing. This is one of the
requirements of thread safety (one that Rust normally allows us not to think
about), but it's worse than that: consider that in cases like <code>SIGSEGV</code>, our 
actions <em>inside</em> the signal handler might trigger further calls (i.e. it can
be <em>inadvertently</em> recursive, or recursive without any obvious sign of
recursion).</p>
<p>If you're thinking that it sounds like we've entered the danger zone at this
point, then you're dead right. Don't worry - <a href="https://man7.org/linux/man-pages/man7/signal-safety.7.html"><code>man 7 signal-safety</code></a>
is here to help us out:</p>
<blockquote>
<p>To avoid problems with unsafe functions, there are two possible
choices:</p>
<ol>
<li>
<p>Ensure that (a) the signal handler calls only async-signal-
safe functions, and (b) the signal handler itself is re-entrant
with respect to global variables in the main program.</p>
</li>
<li>
<p>Block signal delivery in the main program when calling
functions that are unsafe or operating on global data that is
also accessed by the signal handler.</p>
</li>
</ol>
</blockquote>
<p>We can start by saying that 2 is not an option: we're exactly trying to handle
an incoming signal, so blocking delivery is going to defeat the whole object.</p>
<p>So how about option 1? Well, 1.(b) sort of <em>smells</em> quite satisfiable: we're
working in Rust, and Rust won't let us modify global objects in a non-thread-safe
way... so does that also imply re-entrancy? No it does not üòÖ! Quite the
opposite in fact: the thing we'd lean on to coordinate execution with the main
thread would be a mutex. Rust's (unix) mutexes are built on POSIX mutex, and have
<a href="https://github.com/rust-lang/rust/blob/master/library/std/src/sys/unix/mutex.rs#L29">this</a>
to say on the topic:</p>
<blockquote>
<p>...we instead create the mutex with type PTHREAD_MUTEX_NORMAL which is 
guaranteed to deadlock if we try to re-lock it from the same thread...</p>
</blockquote>
<p>... and with good reason! If you want the details, I suggest you follow the link 
and have a good read - basically it's to avoid Undefined Behaviour...
nonetheless, this is firmly <em>not</em> going to be re-entrant.</p>
<p>All of this is moot anyway, because of 1.(a):</p>
<blockquote>
<p>the signal handler calls only async-signal-safe functions</p>
</blockquote>
<p>What does it take for a function to be &quot;async-signal-safe&quot; anyway? Well,
it's a pretty uncomplicated answer: there is a list of functions at the bottom
of the <code>man</code> page which POSIX declares to be &quot;async-signal-safe&quot;, and anything else
is out of bounds - and in particular the relevant <code>pthread_mutex_</code> functions are
off the menu. </p>
<p>Just to give a taste of the sorts of things we can't do in a signal handler:</p>
<ul>
<li>anything involving locks, as we've seen above</li>
<li><code>stdio</code> (so, printing to the screen - although we got away with it above)</li>
<li><code>malloc</code> (so, no allocating memory)</li>
<li>... the list goes on.</li>
</ul>
<p>We'll spend the rest of this post by talking about some of the techniques we can use for
getting information out of our signal handlers and into our application code.</p>
<h1 id="communicating-with-the-application-from-a-signal-handler">communicating with the application from a signal handler.</h1>
<p>Luckily, it's safe to say that the Unix process model is not completely broken. 
In the rest of this article we'll look at addressing 1: we'll stay at a low level 
and see a couple of ways we <em>can</em> get information about signals back onto our 
application code safely, and escape the confines of &quot;async-signal-safe&quot; code.</p>
<h2 id="the-self-pipe-trick">the self-pipe trick</h2>
<p>The careful reader of the <a href="https://man7.org/linux/man-pages/man7/signal-safety.7.html">signal-safety</a>
man page may have noticed a function that gives us something of an escape hatch: <code>write</code> is available.</p>
<p><code>write</code> opens up the door to exfiltrating data from our signal-handler to another thread, in a &quot;trick&quot;
described in <a href="https://cr.yp.to/docs/selfpipe.html">D. J. Bernstein's article on the topic</a>. Let's see
that in action; we'll drop down to C since we're going to be talking with <code>libc</code> a lot for this, and
all Rust's <code>unsafe</code> ceremony doesn't add much here:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">static int</span><span style="color:#c0c5ce;"> pipefds[</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">] = {</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">};

</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">signal_handler</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">signum</span><span style="color:#c0c5ce;">)
{
    uint8_t empty[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">] = {</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">};
    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> write_fd = pipefds[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">];
    </span><span style="color:#bf616a;">write</span><span style="color:#c0c5ce;">(write_fd, empty, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);                 </span><span style="color:#65737e;">// 3
</span><span style="color:#c0c5ce;">}

</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">handle_signal</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">read_pipe_fd</span><span style="color:#c0c5ce;">)
{
    uint8_t buff[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">] = {</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">};
    </span><span style="color:#bf616a;">read</span><span style="color:#c0c5ce;">(read_pipe_fd, buff, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);               </span><span style="color:#65737e;">// 4
    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">Received signal</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;);
}

</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">()
{
    </span><span style="color:#bf616a;">pipe</span><span style="color:#c0c5ce;">(pipefds)                              </span><span style="color:#65737e;">// 1
    </span><span style="color:#bf616a;">fcntl</span><span style="color:#c0c5ce;">(pipefds[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">], F_SETFD, O_NONBLOCK);

    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> read_fd = pipefds[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">];

    </span><span style="color:#96b5b4;">signal</span><span style="color:#c0c5ce;">(SIGINT, signal_handler);            </span><span style="color:#65737e;">// 2

    </span><span style="color:#b48ead;">while</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">true</span><span style="color:#c0c5ce;">) {
        </span><span style="color:#bf616a;">handle_signal</span><span style="color:#c0c5ce;">(read_fd);
    }
}

</span></code></pre>
<p>Error handling and includes omitted for brevity; you can find a full listing <a href="https://gist.github.com/jelford/80367bc790ad1a46a3aa25e413e4eaf2">here</a>
if you'd like to download and run it yourself.</p>
<p>So there's quite a bit to unpack here:</p>
<ol>
<li>We set up a <a href="https://www.man7.org/linux/man-pages/man2/pipe.2.html"><code>pipe</code></a>, which works just
like a pipe in the shell: you write data in one end and read it out the other end. The contents
of <code>pipefds</code> is just two file descriptors, which we'll use to shimmy data from the signal-handler
into our main thread of execution. We set the writer up as non-blocking - we don't want any blocking
in the signal handler.</li>
<li>Now we install our signal handler, same as before</li>
<li>In the signal handler, we're allowed to use <code>write</code> to send data back to the main thread - nice.</li>
<li>Finally, in the main thread, whenever we can read from our pipe, we know that the signal handler
was fired.</li>
</ol>
<p>Nice! So we're able to pull information from our signal handler into the main thread. Inside <code>handle_signal</code>,
we're back to a normal execution context, and we don't have to worry about all that signal-safety stuff we
talked about before. Since we're using a file descriptor on the read side, we can hook that into a normal
event loop (based on <code>poll</code>/<code>select</code>/<code>epoll</code> or whatever). Here, we'll just do blocking reads in a loop -
that's enough to show how it works.</p>
<h2 id="signalfd">signalfd</h2>
<p>Wouldn't it be convenient if we didn't have to set up these pipes and marshall data back to
the main thread ourselves? <code>signalfd</code> is exactly that. From
<a href="https://man7.org/linux/man-pages/man2/signalfd.2.html">the man page</a>:</p>
<blockquote>
<p>signalfd - create a file descriptor for accepting signals</p>
</blockquote>
<p>Like we were discussing before: once we have a file descriptor, we can handle 
that using familiar tools like <code>select</code>, <code>poll</code>, and <code>epoll</code> - in our existing 
event loops, in our normal thread contexts. Let's see how that looks - and 
we'll stay in C since we're still speaking to <code>libc</code>:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">handle_signal</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">int</span><span style="color:#c0c5ce;">);

</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">()
{
    sigset_t mask;
    </span><span style="color:#bf616a;">sigemptyset</span><span style="color:#c0c5ce;">(&amp;mask);
    </span><span style="color:#bf616a;">sigaddset</span><span style="color:#c0c5ce;">(&amp;mask, SIGINT);

    </span><span style="color:#bf616a;">sigprocmask</span><span style="color:#c0c5ce;">(SIG_SETMASK, &amp;mask, </span><span style="color:#d08770;">NULL</span><span style="color:#c0c5ce;">);                </span><span style="color:#65737e;">// 1

    </span><span style="color:#b48ead;">int</span><span style="color:#c0c5ce;"> signal_fd = </span><span style="color:#bf616a;">signalfd</span><span style="color:#c0c5ce;">(-</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, &amp;mask, SFD_NONBLOCK);    </span><span style="color:#65737e;">// 2

    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> pollfd pollfd = {
        .</span><span style="color:#bf616a;">fd </span><span style="color:#c0c5ce;">= signal_fd,
        .</span><span style="color:#bf616a;">events </span><span style="color:#c0c5ce;">= POLLIN,
    };

    </span><span style="color:#b48ead;">while </span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">poll</span><span style="color:#c0c5ce;">(&amp;pollfd, </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">5000</span><span style="color:#c0c5ce;">) &gt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)                    </span><span style="color:#65737e;">// 3
    </span><span style="color:#c0c5ce;">{
        </span><span style="color:#bf616a;">handle_signal</span><span style="color:#c0c5ce;">(pollfd.</span><span style="color:#bf616a;">fd</span><span style="color:#c0c5ce;">);
    }
}

</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">handle_signal</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">signal_fd</span><span style="color:#c0c5ce;">)
{
    </span><span style="color:#b48ead;">struct</span><span style="color:#c0c5ce;"> signalfd_siginfo siginfo;
    ssize_t s;
    s = </span><span style="color:#bf616a;">read</span><span style="color:#c0c5ce;">(signal_fd, &amp;siginfo, sizeof(siginfo));       </span><span style="color:#65737e;">// 4
    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(s != sizeof(siginfo))
    {
        </span><span style="color:#96b5b4;">perror</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">read</span><span style="color:#c0c5ce;">&quot;);
        </span><span style="color:#96b5b4;">exit</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
    }

    uint32_t signo = siginfo.</span><span style="color:#bf616a;">ssi_signo</span><span style="color:#c0c5ce;">;
    </span><span style="color:#b48ead;">char </span><span style="color:#c0c5ce;">*signame = </span><span style="color:#bf616a;">strsignal</span><span style="color:#c0c5ce;">(signo);

    </span><span style="color:#96b5b4;">printf</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">Received signal </span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;"> (</span><span style="color:#d08770;">%s</span><span style="color:#a3be8c;">)</span><span style="color:#96b5b4;">\n</span><span style="color:#c0c5ce;">&quot;, signo, signame);
}
</span></code></pre>
<p>Again, I've omitted all the error handling and includes for brevity; you can get a full copy
of the code <a href="https://gist.github.com/jelford/d8850f357c26ee6840290f7ad89c097b">here</a> if you'd like to run it yourself.
Here's what's going on:</p>
<ol>
<li>We start by letting the runtime know that we don't want interrupt signals to run according to their normal
disposition. Instead, they should be blocked, and queued up for us to read synchronously.</li>
<li>Install a <code>signalfd</code> that will be used to read the signals that we just masked...</li>
<li>This is where the magic happens: we get notified that there's a signal for us to read - we call out to
<code>handle_signal</code> process it.</li>
<li>The same info that would have been sent to us via a signal handler is available to read from our file
descriptor.</li>
</ol>
<p>And just as before: <code>handle_signal</code> is just <em>normal</em> code executing in a <em>normal</em> context. We have regained
access to all those convenient facilities like mutexes and message queues and memory allocation that make
life great. I've set up a little <code>poll</code> loop here for the sake of exposition, but just like in the self-pipe
trick, we can pass our file descriptor to <code>select</code> or <code>epoll</code> or whatever event loop you've got going in your application.</p>
<p>So, we're done, right? Well, not quite--</p>
<ol>
<li>we did say we would deal with signals in <em>rust</em>, so in the next section we'll see that.</li>
<li>there are a couple of problems with <code>signalfd</code> that I haven't mentioned so far: most notably the interaction
with child processes. Let's cover that before we move on.</li>
</ol>
<p>In (1) above, we saw that we blocked the delivery of signals, since we want to handle them
ourselves through our <code>signalfd</code>. Here's the rub: signal masks are inherited by child processes,
while the whole <code>signalfd</code> infrastructure is not. This is a problem; it means that child processes
will:</p>
<p>a. not receive signals in the normal way, if they were masked in the parent process,
b. not handle them any other way either.</p>
<p>The child processes <em>could</em> clear their signal masks - but in practice most of us don't do that
when we start our programmes. You could imagine letting the child processes inherit the <code>signalfd</code>,
but it's the same issue; they would need to arrange to handle the signals themselves. This is a bit
thorny - <a href="https://ldpreload.com/blog/signalfd-is-useless">maybe even a deal-breaker</a>.</p>
<h2 id="the-signal-hook-library">the <code>signal-hook</code> library</h2>
<p>Let's get to the point: the <a href="https://github.com/vorner/signal-hook"><code>signal-hook</code></a> library has what you need.
It implements a couple of the things you would hope for:</p>
<ul>
<li><a href="https://docs.rs/signal-hook/0.3.10/signal_hook/iterator/index.html">An <code>Iterator</code> over incoming signals</a>, which you pull from the main thread</li>
<li>Signal information is pulled out of the signal handler <a href="https://docs.rs/signal-hook/0.3.10/signal_hook/low_level/pipe/index.html">via the self-pipe trick</a></li>
<li>And you're done!</li>
</ul>
<p>And this time we really are done. <code>signal-hook</code> also provides convenient adapters 
<a href="https://docs.rs/signal-hook-tokio/0.3.0/signal_hook_tokio/">for use in a tokio event loop</a>,
or equivalently <a href="https://docs.rs/signal-hook-async-std/0.2.1/signal_hook_async_std/">for <code>async-std</code></a>.</p>
<p>Let's wrap it up with an update to the example we started with:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">use </span><span style="color:#c0c5ce;">signal_hook::consts::*;
</span><span style="color:#b48ead;">use </span><span style="color:#c0c5ce;">signal_hook::iterator::Signals;
</span><span style="color:#b48ead;">use </span><span style="color:#c0c5ce;">crossbeam::channel::{select, </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">, Sender, Receiver, after};
</span><span style="color:#b48ead;">use </span><span style="color:#c0c5ce;">std::time::Duration;

</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">await_interrupt</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">interrupt_notification_channel</span><span style="color:#c0c5ce;">: Sender&lt;()&gt;) {
    </span><span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> signals = Signals::new(&amp;[                              </span><span style="color:#65737e;">// 1
        </span><span style="color:#d08770;">SIGINT</span><span style="color:#c0c5ce;">,
    ]).</span><span style="color:#96b5b4;">unwrap</span><span style="color:#c0c5ce;">();

    </span><span style="color:#b48ead;">for</span><span style="color:#c0c5ce;"> s in &amp;</span><span style="color:#b48ead;">mut</span><span style="color:#c0c5ce;"> signals {                                        </span><span style="color:#65737e;">// 2
</span><span style="color:#c0c5ce;">        interrupt_notification_channel.</span><span style="color:#96b5b4;">send</span><span style="color:#c0c5ce;">(());                   </span><span style="color:#65737e;">// 3
    </span><span style="color:#c0c5ce;">}
}

</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">() {
    </span><span style="color:#b48ead;">let </span><span style="color:#c0c5ce;">(interrupt_tx, interrupt_rx) = channel::unbounded();
    std::thread::spawn(</span><span style="color:#b48ead;">move </span><span style="color:#c0c5ce;">|| { </span><span style="color:#96b5b4;">await_interrupt</span><span style="color:#c0c5ce;">(interrupt_tx)});

    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> timeout = </span><span style="color:#96b5b4;">after</span><span style="color:#c0c5ce;">(Duration::from_secs(</span><span style="color:#d08770;">5</span><span style="color:#c0c5ce;">));
    </span><span style="color:#b48ead;">loop </span><span style="color:#c0c5ce;">{
        select! {
            </span><span style="color:#96b5b4;">recv</span><span style="color:#c0c5ce;">(interrupt_rx) -&gt; _ =&gt; {                           </span><span style="color:#65737e;">// 4
                </span><span style="color:#c0c5ce;">println!(&quot;</span><span style="color:#a3be8c;">Received interrupt notification</span><span style="color:#c0c5ce;">&quot;);
                </span><span style="color:#b48ead;">break</span><span style="color:#c0c5ce;">;
            },
            </span><span style="color:#96b5b4;">recv</span><span style="color:#c0c5ce;">(timeout) -&gt; _ =&gt; {                                </span><span style="color:#65737e;">// 5
                </span><span style="color:#c0c5ce;">println!(&quot;</span><span style="color:#a3be8c;">Finally finished the long task</span><span style="color:#c0c5ce;">&quot;);
                </span><span style="color:#b48ead;">break</span><span style="color:#c0c5ce;">;
            }
        }
    }
}
</span></code></pre>
<p>In this example, I'm using <code>crossbeam</code> <code>channels</code> and <code>select</code> handle
multiplexing events (namely, timeouts vs. interrupt notifications),
but you could do the same thing without <code>crossbeam</code> in <code>tokio</code> or <code>async-std</code>
runtime - and <code>signal-handler</code>'s tokio adapter will let you do just that.
Let's go through the main points:</p>
<ol>
<li>Installing the signal handler. This does - eventually - pretty much
what you'd expect from the start of the post, with a <a href="https://docs.rs/signal-hook-registry/1.4.0/src/signal_hook_registry/lib.rs.html#174">a call through to <code>libc::sigaction</code></a>.</li>
<li>Signal info is fed back to us via a self-pipe. <code>signal-hook</code> wraps
that interaction up in a nice <code>Iterator</code> interface so that we never
have to worry about.</li>
<li>We're in a normal, non-signal-handler execution context, so we
can safely use a <code>crossbeam::channel</code> (or any other mechanism
we like) to communicate between threads.</li>
<li>Finally, when we get an interrupt on the main thread, we can break
out of our loop.</li>
<li>It's not really about signals, but it's nice to note that <code>crossbeam</code>
also provides a nice timeout mechanism.</li>
</ol>
<p>And that's really truly the end.</p>
<h1 id="conclusion">Conclusion</h1>
<p>We've seen that signal handlers are subject to some significant restrictions,
and we can use the &quot;self pipe&quot; technique to escape their shackles. <code>signal-hook</code>
makes dealing with this stuff convenient.</p>
<p>There are two other signals-related topics that I'd like to cover:</p>
<ul>
<li>event coalescing, which I mentioned this briefly at the end of the section on <code>signalfd</code></li>
<li>non-local behavior, which we haven't seen here but opens up its own fresh can of worms
If those topics sound interesting to you, do drop me a note to remind me to make it happen.</li>
</ul>

        </main>
    </article>


    </div>

    <!-- 
        Hey there friend! Don't mind me, I'm just trying to get some idea of whether anyone reads this stuff. 
        Goatcounter (here: https://www.goatcounter.com/) tries to give that, and claims to do so without
        tracking. I hope that's acceptable to you.
    -->
    <noscript><img src="https://jelford.goatcounter.com/count?p=/test-img"></noscript>
    <script data-goatcounter="https://jelford.goatcounter.com/count"
        async src="/assets/vendor/goatcounter.js"></script>
  </body>
</html>
