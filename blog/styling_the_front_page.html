<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="generator" content="pandoc" />
	<link href="data:text/css,%0A%0Abody%20%7B%0A%20%20%20%20font%2Dfamily%3A%20sans%2Dserif%3B%0A%20%20%20%20margin%2Dleft%3A%20auto%3B%0A%20%20%20%20margin%2Dright%3A%20auto%3B%0A%7D%0A%0A%40media%20%28min%2Dwidth%3A%2055em%29%20%7B%0A%20%20%20%20body%20%7B%0A%20%20%20%20%20%20%20%20width%3A%2055em%3B%0A%20%20%20%20%7D%0A%7D%0A%0A%2Eblog%5Fpost%20%7B%0A%09border%2Dtop%3A%201px%20solid%20grey%3B%0A%7D%0A%0Aa%2Epermalink%20%7B%0A%20%20%20%20font%2Dsize%3A%200%2E9em%3B%0A%20%20%20%20font%2Dfamily%3A%20monospace%3B%0A%7D%0A%0Anav%20ul%20%7B%0A%09list%2Dstyle%2Dtype%3A%20none%3B%0A%09margin%3A%200%3B%0A%09padding%3A%200%3B%0A%7D%0A%0Anav%20ul%20li%20%7B%0A%09display%3A%20inline%3B%0A%09margin%2Dright%3A%200%2E3em%3B%0A%7D%0A" rel="stylesheet" type="text/css" />
</head>
<body>
<article>
<h1 class="title">Bringing things together as a blog</h1>
<a class="permalink" href="/blog/styling_the_front_page.html">permalink</a>
<p>So far we've taken a simple approach to gluing everyting together, but it'd be good to have a couple of the niceties that make things seem like more than just... a wall of text on a page.</p>
<p>I can think of a couple of nice features that would make things look better:</p>
<ul>
<li>Whole-page styling, e.g. link back to homepage</li>
<li>Permalinks for individual posts</li>
<li>Meta information on the posts (e.g. published date)</li>
</ul>
<p>I still want to actually <em>write</em> all the posts in simple markdown, but to get e.g. permalinks, we're going to need the blog posts to make sense as standalone HTML pages, and then when we bring them together in the front page, we'll need to strip out just the content. First thing: we'll have pandoc translate individual blog entries into standalone HTML pages</p>
<pre><code>blog/%.html : blog/%.md 
    pandoc --email-obfuscation=javascript --self-contained --css=style.css --standalone $&lt; -f markdown -t html5 -o $@</code></pre>
<p>The <code>--standalone</code> argument instructs pandoc to make a full HTML file (complete with headers, meta, and so on), while the <code>--self-contained</code> flag instructs it to inline all the CSS. We don't necessarily want that in there permanently, but if you try to build without it, pandoc with get the path wrong (<code>style.css</code> sits in the root, but pandoc has no way to know that the output document will be within a folder; it uses the relative path from the current working directory).</p>
<p>That's enough to get us a reasonable output if we browse to the individual blog posts by name, but there are a few things left:</p>
<ul>
<li>There's no way to browse to the individual blog posts; we still don't have any kind of permalink to them.</li>
<li><code>compile_blog</code> is still sucking in the entire content of the blog posts into the front page. Whilst modern browsers can figure out what's sensible, it means we're left with duplicate <code>&lt;head&gt;</code> blocks, css getting included several times, and so on.</li>
</ul>
<p>Let's address the first point first - it should be easy enough to add a link in the body of every blog post to its own path.</p>
<h2 id="adding-permalinks">Adding Permalinks</h2>
<p>So far, we've just been using pandoc's default HTML template, plus a very simple stylesheet. The default HTML template has some useful bits in it; it gives us a <code>&lt;head&gt;</code> section with some reasonable <code>&lt;meta&gt;</code> tags, and if we take the time to inspect it, we'll see there's also some sort of shim to make things nicer for users with an older version of internet explorer.</p>
<p>It's time to replace it with our own template, which will be even simpler:</p>
<ul>
<li>We won't bother with the <code>&lt;meta&gt;</code> tags for now - maybe we'll come back later when we explicitly want them as a feature, and think about how we might want them populated</li>
<li>We won't bother with an HTML5 shim anymore; internet explorer's on version 11 now, so hopefully there aren't too many people out there still on version 8.</li>
</ul>
<p>We do at least still want CSS to be passed in, so we'll make our new template with reference to the default. You can see that by running:</p>
<pre><code>pandoc -D html</code></pre>
<p>There's some stuff in there we might want about authors, and it looks like it'll try to generate some headers, title, and so on for us. That's all very nice, but to begin with let's keep things super-simple and strip it right down:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot; /&gt;
$for(css)$
        &lt;link rel=&quot;stylesheet&quot; href=&quot;$css$&quot; type=&quot;text/css&quot; /&gt;
$endfor$
&lt;/head&gt;
&lt;body&gt;
&lt;article&gt;
$body$
&lt;/article&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>What've we got here?</p>
<ul>
<li>A simple HTML 5 doctype (a simple &quot;<code>html</code>&quot; is all we need)</li>
<li>Any CSS specified on the commandline will get added in.</li>
<li>It's wrapped in an <code>&lt;article&gt;</code> tag because it's an (article)[https://www.w3.org/TR/html5/sections.html#the-article-element]. It's good to remember that our markup has semantic value.</li>
</ul>
<p>Now we've got a working standalone page that we can add to, let's get to adding in our permalinks. We'll modify the body section of our template to include a link to its &quot;canonical&quot; location:</p>
<pre><code>&lt;body&gt;
&lt;div&gt;&lt;a href=&quot;$permalink$&quot;&gt;permalink&lt;/a&gt;&lt;/div&gt;
$body$
&lt;/body&gt;</code></pre>
<p>If let's put our new template in a file somewhere, and tell pandoc to use that instead of the default. The template file:</p>
<pre><code>cat &gt; blog/pandoc_html_template.html.template &lt;&lt; EOF
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;meta name=&quot;generator&quot; content=&quot;pandoc&quot; /&gt;
$for(css)$
    &lt;link rel=&quot;stylesheet&quot; href=&quot;$css$&quot; type=&quot;text/css&quot; /&gt;
$endfor$
&lt;/head&gt;
&lt;body&gt;
&lt;article&gt;
&lt;div&gt;&lt;a href=&quot;$permalink$&quot;&gt;permalink&lt;/a&gt;&lt;/div&gt;
$body$
&lt;/article&gt;
&lt;/body&gt;
&lt;/html&gt;
EOF</code></pre>
<p>And then we update our Makefile:</p>
<pre><code>blog/%.html : blog/%.md pandoc_html_template.html.template
    pandoc --email-obfuscation=javascript --self-contained --css=style.css --standalone --template=blog/pandoc_html_template.html.template $&lt; -f markdown -t html5 -o $@</code></pre>
<p>Notice we also added the template to the list of dependencies for each blog entry's HTML output. This ensures that when we change the template, our make script will pick up the changes and know that it needs to regenerate <em>every</em> blog post.</p>
<p>Let's give it a whirl, and see what we get:</p>
<div style="border: 1px solid grey">
<a href>permalink</a>
<h1>
Bringing things together as a blog
</h1>
<div>
...
</div>
</div>
<p>Ah, that doesn't look to good - the link sitting above the title. Darn. Looks like we might want to do something better with how we work with titles, so we can put content below them in our templates. Taking another look at pandoc's default template, it incldes the following lines:</p>
<pre><code>$if(title)$
&lt;div id=&quot;$idprefix$header&quot;&gt;
&lt;h1 class=&quot;title&quot;&gt;$title$&lt;/h1&gt;
...</code></pre>
<p>The &quot;title&quot; in the case comes from metadata at the top of the file, which pandoc reads in, and then makes available in the template rendering context. You can get the details on what kinds of things we might want to put in meta- data blocks from the pandoc <a href="http://pandoc.org/README.html#metadata-blocks">documentation</a>. We're interested in the <code>% title</code> element. So far, I've been putting an H element at the top of every blog post, by just writing:</p>
<pre><code>% Bringing things together as a blog
...</code></pre>
<p>Maybe it's time to <em>tell pandoc</em> what the title of the post is, and then let it figure out how to render the titles. So, as part of adding this feature, I've gone through and replaced all the headers with metadata blogs; the lines above become:</p>
<pre><code>% Brining things together as a blog</code></pre>
<p>and our template body changes to:</p>
<pre><code>&lt;body&gt;
&lt;article&gt;
&lt;h1 class=&quot;title&quot;&gt;$title$&lt;/h1&gt;
&lt;a href=&quot;&quot;&gt;permalink&lt;/a&gt;
$body$
&lt;/article&gt;
&lt;/body&gt;</code></pre>
<p>I'm not going to go though manually changing the first line of every blog post; I'll just run:</p>
<pre><code>find blog -name '*.md' -exec sed -e 's/^# /% /g' {} \;</code></pre>
<p>to get all the <code>&lt;h1&gt;</code> elements.</p>
<p>Finally, we're still missing a crucial detail - all our permalinks are missing their <code>href</code> attributes (or rather, they're all blank). We need to pass in the relative file path to the template when we generate the page. That's one last tweak to our Makefile:</p>
<pre><code>pandoc --email-obfuscation=javascript --self-contained --css=style.css --standalone --template=blog/pandoc_html_template.html.template -V permalink=/$@ $&lt; -f markdown -t html5 -o $@</code></pre>
<p>Hey presto - we get html that looks like this:</p>
<pre><code>&lt;body&gt;
&lt;article&gt;
&lt;h1&gt;...&lt;/h1&gt;
&lt;a class=&quot;permalink&quot; href=&quot;blog/styling_the_front_page.html&quot;&gt;permalink&lt;/a&gt;
&lt;p&gt; ...
&lt;/article&gt;</code></pre>
<h2 id="tidying-up-the-main-page">Tidying up the main page</h2>
<p>Now that we've made the changes we needed to add permalinks, it's time we clear up the main page. Let's stop the <code>compile_blog</code> step from pulling in extraneous HTML from the sub pages, for a start. The approach I'm going to take is to parse sub-pages and extract just their <code>body</code> elements. It's easy to do with the very adequate <a href="http://www.crummy.com/software/BeautifulSoup/">Beautiful Soup</a> library. This is the first piece of third-party software I'm using so far for this project - I'll start a local <a href="http://virtualenv.readthedocs.org/en/latest/">virtualenv</a> to keep my external dependencies tidily separated from the rest of my system:</p>
<pre><code>sudo pip install --upgrade pip setuptools virtualenv wheel # update everything
virtualenv . --python=python3
. bin/activate
pip install --upgrade beautifulsoup4</code></pre>
<p>I'll also add some entries to <code>.gitignore</code> to make that not be a huge pain. Helpfully, there's a github project that collects together commonly used <code>.gitignore</code> snippets <a href="https://github.com/github/gitignore">here</a>, or if you prefer to have someone do your text-file-gluing-togther for you, there's a neat wrapper around there <a href="https://www.gitignore.io/">here</a>.</p>
<p>One more thing - I'll want to check in a list of dependencies:</p>
<pre><code>pip freeze &gt; requirements.txt
git add requirements.txt</code></pre>
<p>Now we'll need to do</p>
<pre><code>. bin/activate</code></pre>
<p>whenever we start working on the blog, to set up our working environment correctly.</p>
<p>Right, back to the business of sorting out the front page. We'll modify <code>compile_blog</code> to extract just the <code>&lt;article&gt;</code> section of our sub-pages:</p>
<pre><code>class BlogPost():
    ...
    def content(self):
        with open(self.file_path, 'r') as f:
            soup = BeautifulSoup(f.read())
        return soup.body.article
</code></pre>
<p><code>BlogPost.content()</code> now returns a beautifulsoup HTML element - let's update the compile step to be aware of that, and apply any top-level styling:</p>
<pre><code>def compile(...):
    ...
    for b in reversed(sorted(blog_posts, key=lambda b: b.timestamp())):
        post = b.content()
        post['class'] = 'blog_post' # add styling that applies at the top level
        output_file.write(str(post))</code></pre>
<h2 id="styling-the-main-page">Styling the main page</h2>
<p>So we're finally in a place where the main page has some reasonable markup on it, embedding individual blog posts, that can be linked to as standalone pages. Nice going. Finally, let's add some simple styling that links back to the site's main page, with some borders, and then let's call it a day. We'll come back and add in date information to individual posts next time maybe.</p>
<p>First, I'm just going to add a header to the top of every page. We'll modify the front page as follows:</p>
<pre><code>def compile(output_file, blog_posts):
    ...
    output_file.write('&lt;header&gt;&lt;h1&gt;jelford\'s blog&lt;/h1&gt;&lt;nav&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;/&quot;&gt;home&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/jelford&quot;&gt;github&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/nav&gt;&lt;/header&gt;')</code></pre>
<p>That gives us the main links we'll want at the top, along with an originally named header. One last thing - add the CSS to get the links to flow horizontally:</p>
<pre><code>nav ul {
    list-style-type: none;
    margin: 0;
    padding: 0;
}

nav ul li {
    display: inline;
    margin-right: 0.3em;
}</code></pre>
</article>
</body>
</html>
