<h2 id="building-a-better-blog-organising-output">Building a better blog: organising output</h2>
<p>In the last entry, I walked through using a simple make-file to generate the HTML for a simple blog - it will convert a collection of markdown files into HTML snippets, then concatenate them into a single &quot;blog&quot; page.</p>
<p>In this entry, we'll build on that by managing multiple entries more in a nicer way:</p>
<ul>
<li>we'll make it put them into some sort of order (based on when they were written)</li>
<li>we'll style the resulting page to make it easier to see where one entry stops and the next one starts</li>
</ul>
<h3 id="faster-feedback">Faster feedback</h3>
<h4 id="see-it-in-a-browser">See it in a browser</h4>
<p>First, let's get ourselves set up with a fast feedback loop. We'd like to see fully-rendered output, as it'll look to readers, in a browser, immediately as we make updates.</p>
<p>We can open up out rendered output in a web browser easily enough:</p>
<pre><code>firefox ./blog.html</code></pre>
<p>... but most browsers will behave a little differently when we view <code>file:///</code> URLs compared to if they were on the web. We can get the &quot;real thing&quot; without much extra hassle though:</p>
<pre><code>python3 -m http.server --bind 127.0.0.1</code></pre>
<p>will run a simple http server that serves up the current working directory. The <code>--bind</code> on the end instructs it to only listen for connections from <code>localhost</code> - it's not much, but it's probably best not to open up a socket to the whole world if we don't have to. If you're using an older version of python you can do:</p>
<pre><code>python2 -m SimpleHTTPServer</code></pre>
<h4 id="make-all-the-time">Make all the time</h4>
<p>If we were building a JavaScript app, we'd probably have set up a file watch by now. We should do that here:</p>
<pre><code>watch make</code></pre>
<p>That'll run <code>make</code> every couple of seconds. It's not as event-driven as we might be used to from <code>inotify</code>-type file watching, but it'll do us. Now, every time we save a file, we should see the update in our browsers as soon as we refresh.</p>
<h4 id="see-it-straight-away">See it straight away</h4>
<p>One last thing: while we're working on things, let's just have our browser auto-refresh the page.</p>
<p>We'll put this in the <code>&lt;head&gt;</code> of our HTML:</p>
<pre><code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;5&quot; &gt;</code></pre>
<p>So our final make step now looks like this:</p>
<pre><code>blog.html : $(blog_objects) 
    echo &#39;&lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot; &gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;2&quot; &gt;&lt;/head&gt;&lt;body&gt;&#39; &gt; blog.html 
    cat $(blog_objects) &gt;&gt; blog.html 
    echo &#39;&lt;/body&gt;&lt;/html&gt;&#39; &gt;&gt; blog.html</code></pre>
<p>Now, nobody like pages that auto-refresh while they're looking at them, so I'd like to take this out before pushing anything up, but there are a couple of things that mean it wouldn't be <em>the worst thing ever</em> if we forget:</p>
<ul>
<li>It looks like (Firefox at least) it nice enough to maintain your postion on the page between refreshes</li>
<li>Because we're generating a static page (that github's going to server statically), every request should actually hit the cache (unless there's been a real change), so it won't put as much extra load on the network/server as you might expect.</li>
</ul>
<p>Which is kind of nice...</p>
<h3 id="move-our-compilation-into-a-script">Move our compilation into a script</h3>
<p>I don't like writing raw bash (or makefiles, for that matter) any more than the next person. Let's move our bash step into a separate script:</p>
<pre><code>blog.html : $(blog_objects)
    ./compile_blog $(blog_objects)

--- ./compile_blog ---
#! /usr/bin/env sh
echo &#39;&lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot; &gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;2&quot; &gt;&lt;/head&gt;&lt;body&gt;&#39; &gt; blog.html 
cat $@ &gt;&gt; blog.html 
echo &#39;&lt;/body&gt;&lt;/html&gt;&#39; &gt;&gt; blog.html</code></pre>
<p>Phew. That's better. Okay, now let's move to using a nicer language than <code>sh</code> for manipulating files. We'll use python, since that's what I like.</p>
<pre><code>#! /usr/bin/env python3

import argparse
import sys

def parse_args(args):
    parser = argparse.ArgumentParser(description=&#39;Combine blog posts into a single page&#39;)
    parser.add_argument(&#39;output_file&#39;, type=argparse.FileType(&#39;w&#39;))
    parser.add_argument(&#39;input_files&#39;, nargs=argparse.REMAINDER)

    args = parser.parse_args(sys.argv[1:])
    return args.output_file, args.input_files


if __name__ == &#39;__main__&#39;:
    output_file, input_files = parse_args(sys.argv[1:])
        
    output_file.write(&#39;&lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot; &gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;2&quot; &gt;&lt;/head&gt;&lt;body&gt;&#39;)

    for entry_path in input_files:
        with open(entry_path, &#39;r&#39;) as blog_entry:
            output_file.write(blog_entry.read())

    output_file.write(&#39;&lt;/body&gt;&lt;/html&gt;&#39;)</code></pre>
<p>Finally, let's make it so that our main page re-compiles any time we make changes to its build script:</p>
<pre><code>blog.html : $(blog_objects) compile_blog
    ...</code></pre>
<h3 id="ordering-our-blog-posts">Ordering our blog posts</h3>
<p>Now we're in proper programming land, we can start to be more sophisticated with how we work with our files.</p>
<p>Let's start by moving them into some sort of very basic domain model:</p>
<pre><code>class BlogPost():
    def __init__(self, file_path):
        self.file_path = file_path

    def content(self):
        with open(self.file_path, &#39;r&#39;) as f:
            return f.read()

def compile(output_file, blog_posts):
    output_file.write(&#39;&lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot; &gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;2&quot; &gt;&lt;/head&gt;&lt;body&gt;&#39;)

    for b in blog_posts:
        output_file.write(b.content())

    output_file.write(&#39;&lt;/body&gt;&lt;/html&gt;&#39;)

def compile_files(output_file, input_paths):
    compile(output_file, (BlogPost(p) for p in input_paths))

if __name__ == &#39;__main__&#39;:
    compile_files(*parse_args(sys.argv[1:]))</code></pre>
<p>Now we've got a model, we can sort the blog posts by the details - in this case, I want the time the file was create (or, added to git, as a reasonable proxy).</p>
<pre><code>import subprocess
import datetime

class BlogPost():
    ...
    def timestamp(self):
        timestamp = subprocess.check_output([&#39;git&#39;, &#39;log&#39;, &#39;--diff-filter=A&#39;, &#39;--pretty=%aD&#39; , &#39;--&#39;, self.file_path]).decode().strip()
        return datetime.strptime(timestamp, &#39;%a, %d %b %Y %H:%M:%S %z&#39;)

...

def compile(...):
    ...
    for b in reversed(sorted(blog_posts, key=lambda b: b.timestamp())):
        ...</code></pre>
<p>Finally, let's put something around each post, so it's easier to see when one post stops and the next one starts:</p>
<pre><code>def compile(...):
    ...
    for b in ...
        output_file.write(&#39;&lt;section class=&quot;blog_post&quot;&gt;&#39;)
        output_file.write(b.content())
        output_file.write(&#39;&lt;/section&gt;&#39;)</code></pre>
<p>And we'll put something in <code>style.css</code> to make that visible:</p>
<pre><code>section.blog_post {
    border-top: 1px solid grey;
}</code></pre>
