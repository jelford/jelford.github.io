<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="generator" content="pandoc" />
	<link href="data:text/css,%0A%0Abody%20%7B%0A%20%20%20%20font%2Dfamily%3A%20sans%2Dserif%3B%0A%20%20%20%20margin%2Dleft%3A%20auto%3B%0A%20%20%20%20margin%2Dright%3A%20auto%3B%0A%7D%0A%0A%40media%20%28min%2Dwidth%3A%2055em%29%20%7B%0A%20%20%20%20body%20%7B%0A%20%20%20%20%20%20%20%20width%3A%2055em%3B%0A%20%20%20%20%7D%0A%7D%0A%0A%2Eblog%5Fpost%20%7B%0A%09border%2Dtop%3A%201px%20solid%20grey%3B%0A%7D%0A%0Aa%2Epermalink%20%7B%0A%20%20%20%20font%2Dsize%3A%200%2E9em%3B%0A%20%20%20%20font%2Dfamily%3A%20monospace%3B%0A%7D%0A%0Anav%20ul%20%7B%0A%09list%2Dstyle%2Dtype%3A%20none%3B%0A%09margin%3A%200%3B%0A%09padding%3A%200%3B%0A%7D%0A%0Anav%20ul%20li%20%7B%0A%09display%3A%20inline%3B%0A%09margin%2Dright%3A%200%2E3em%3B%0A%7D%0A" rel="stylesheet" type="text/css" />
</head>
<body>
<article>
<h1 class="title">Building a better blog: organising output</h1>
<a class="permalink" href="/blog/organising_blog_output_nicely.html">permalink</a>
<p>In the last entry, I walked through using a simple make-file to generate the HTML for a simple blog - it will convert a collection of markdown files into HTML snippets, then concatenate them into a single &quot;blog&quot; page.</p>
<p>In this entry, we'll build on that by managing multiple entries more in a nicer way:</p>
<ul>
<li>we'll make it put them into some sort of order (based on when they were written)</li>
<li>we'll style the resulting page to make it easier to see where one entry stops and the next one starts</li>
</ul>
<h2 id="faster-feedback">Faster feedback</h2>
<h3 id="see-it-in-a-browser">See it in a browser</h3>
<p>First, let's get ourselves set up with a fast feedback loop. We'd like to see fully-rendered output, as it'll look to readers, in a browser, immediately as we make updates.</p>
<p>We can open up out rendered output in a web browser easily enough:</p>
<pre><code>firefox ./blog.html</code></pre>
<p>... but most browsers will behave a little differently when we view <code>file:///</code> URLs compared to if they were on the web. We can get the &quot;real thing&quot; without much extra hassle though:</p>
<pre><code>python3 -m http.server --bind 127.0.0.1</code></pre>
<p>will run a simple http server that serves up the current working directory. The <code>--bind</code> on the end instructs it to only listen for connections from <code>localhost</code> - it's not much, but it's probably best not to open up a socket to the whole world if we don't have to. If you're using an older version of python you can do:</p>
<pre><code>python2 -m SimpleHTTPServer</code></pre>
<h3 id="make-all-the-time">Make all the time</h3>
<p>If we were building a JavaScript app, we'd probably have set up a file watch by now. We should do that here:</p>
<pre><code>watch make</code></pre>
<p>That'll run <code>make</code> every couple of seconds. It's not as event-driven as we might be used to from <code>inotify</code>-type file watching, but it'll do us. Now, every time we save a file, we should see the update in our browsers as soon as we refresh.</p>
<h3 id="see-it-straight-away">See it straight away</h3>
<p>One last thing: while we're working on things, let's just have our browser auto-refresh the page.</p>
<p>We'll put this in the <code>&lt;head&gt;</code> of our HTML:</p>
<pre><code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;5&quot; &gt;</code></pre>
<p>So our final make step now looks like this:</p>
<pre><code>blog.html : $(blog_objects) 
    echo '&lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot; &gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;2&quot; &gt;&lt;/head&gt;&lt;body&gt;' &gt; blog.html 
    cat $(blog_objects) &gt;&gt; blog.html 
    echo '&lt;/body&gt;&lt;/html&gt;' &gt;&gt; blog.html</code></pre>
<p>Now, nobody like pages that auto-refresh while they're looking at them, so I'd like to take this out before pushing anything up, but there are a couple of things that mean it wouldn't be <em>the worst thing ever</em> if we forget:</p>
<ul>
<li>It looks like (Firefox at least) it nice enough to maintain your postion on the page between refreshes</li>
<li>Because we're generating a static page (that github's going to server statically), every request should actually hit the cache (unless there's been a real change), so it won't put as much extra load on the network/server as you might expect.</li>
</ul>
<p>Which is kind of nice...</p>
<h2 id="move-our-compilation-into-a-script">Move our compilation into a script</h2>
<p>I don't like writing raw bash (or makefiles, for that matter) any more than the next person. Let's move our bash step into a separate script:</p>
<pre><code>blog.html : $(blog_objects)
    ./compile_blog $(blog_objects)

--- ./compile_blog ---
#! /usr/bin/env sh
echo '&lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot; &gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;2&quot; &gt;&lt;/head&gt;&lt;body&gt;' &gt; blog.html 
cat $@ &gt;&gt; blog.html 
echo '&lt;/body&gt;&lt;/html&gt;' &gt;&gt; blog.html</code></pre>
<p>Phew. That's better. Okay, now let's move to using a nicer language than <code>sh</code> for manipulating files. We'll use python, since that's what I like.</p>
<pre><code>#! /usr/bin/env python3

import argparse
import sys

def parse_args(args):
    parser = argparse.ArgumentParser(description='Combine blog posts into a single page')
    parser.add_argument('output_file', type=argparse.FileType('w'))
    parser.add_argument('input_files', nargs=argparse.REMAINDER)

    args = parser.parse_args(sys.argv[1:])
    return args.output_file, args.input_files


if __name__ == '__main__':
    output_file, input_files = parse_args(sys.argv[1:])
        
    output_file.write('&lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot; &gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;2&quot; &gt;&lt;/head&gt;&lt;body&gt;')

    for entry_path in input_files:
        with open(entry_path, 'r') as blog_entry:
            output_file.write(blog_entry.read())

    output_file.write('&lt;/body&gt;&lt;/html&gt;')</code></pre>
<p>Finally, let's make it so that our main page re-compiles any time we make changes to its build script:</p>
<pre><code>blog.html : $(blog_objects) compile_blog
    ...</code></pre>
<h2 id="ordering-our-blog-posts">Ordering our blog posts</h2>
<p>Now we're in proper programming land, we can start to be more sophisticated with how we work with our files.</p>
<p>Let's start by moving them into some sort of very basic domain model:</p>
<pre><code>class BlogPost():
    def __init__(self, file_path):
        self.file_path = file_path

    def content(self):
        with open(self.file_path, 'r') as f:
            return f.read()

def compile(output_file, blog_posts):
    output_file.write('&lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot; &gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;2&quot; &gt;&lt;/head&gt;&lt;body&gt;')

    for b in blog_posts:
        output_file.write(b.content())

    output_file.write('&lt;/body&gt;&lt;/html&gt;')

def compile_files(output_file, input_paths):
    compile(output_file, (BlogPost(p) for p in input_paths))

if __name__ == '__main__':
    compile_files(*parse_args(sys.argv[1:]))</code></pre>
<p>Now we've got a model, we can sort the blog posts by the details - in this case, I want the time the file was create (or, added to git, as a reasonable proxy, since I want it to survive renamed, checkouts elsewhere, that sort of thing).</p>
<pre><code>import subprocess
import datetime
import timezone


class BlogPost():
    ...
    def timestamp(self):
        timestamp = subprocess.check_output(['git', 'log', '--diff-filter=A', '--pretty=%aD' , '--', self.file_path]).decode().strip()
        return datetime.strptime(timestamp, '%a, %d %b %Y %H:%M:%S %z') if timestamp \
            else datetime.now(tz=timezone.utc) # if the file's not yet in git

...

def compile(...):
    ...
    for b in reversed(sorted(blog_posts, key=lambda b: b.timestamp())):
        ...</code></pre>
<p>Finally, let's put something around each post, so it's easier to see when one post stops and the next one starts:</p>
<pre><code>def compile(...):
    ...
    for b in ...
        output_file.write('&lt;section class=&quot;blog_post&quot;&gt;')
        output_file.write(b.content())
        output_file.write('&lt;/section&gt;')</code></pre>
<p>And we'll put something in <code>style.css</code> to make that visible:</p>
<pre><code>section.blog_post {
    border-top: 1px solid grey;
}</code></pre>
</article>
</body>
</html>
