<html><head><link rel="stylesheet" type="text/css" href="style.css" ><meta http-equiv="refresh" content="2" ></head><body><section class="blog_post"><h2 id="building-a-better-blog-organising-output">Building a better blog: organising output</h2>
<p>In the last entry, I walked through using a simple make-file to generate the HTML for a simple blog - it will convert a collection of markdown files into HTML snippets, then concatenate them into a single &quot;blog&quot; page.</p>
<p>In this entry, we'll build on that by managing multiple entries more in a nicer way:</p>
<ul>
<li>we'll make it put them into some sort of order (based on when they were written)</li>
<li>we'll style the resulting page to make it easier to see where one entry stops and the next one starts</li>
</ul>
<h3 id="faster-feedback">Faster feedback</h3>
<h4 id="see-it-in-a-browser">See it in a browser</h4>
<p>First, let's get ourselves set up with a fast feedback loop. We'd like to see fully-rendered output, as it'll look to readers, in a browser, immediately as we make updates.</p>
<p>We can open up out rendered output in a web browser easily enough:</p>
<pre><code>firefox ./blog.html</code></pre>
<p>... but most browsers will behave a little differently when we view <code>file:///</code> URLs compared to if they were on the web. We can get the &quot;real thing&quot; without much extra hassle though:</p>
<pre><code>python3 -m http.server --bind 127.0.0.1</code></pre>
<p>will run a simple http server that serves up the current working directory. The <code>--bind</code> on the end instructs it to only listen for connections from <code>localhost</code> - it's not much, but it's probably best not to open up a socket to the whole world if we don't have to. If you're using an older version of python you can do:</p>
<pre><code>python2 -m SimpleHTTPServer</code></pre>
<h4 id="make-all-the-time">Make all the time</h4>
<p>If we were building a JavaScript app, we'd probably have set up a file watch by now. We should do that here:</p>
<pre><code>watch make</code></pre>
<p>That'll run <code>make</code> every couple of seconds. It's not as event-driven as we might be used to from <code>inotify</code>-type file watching, but it'll do us. Now, every time we save a file, we should see the update in our browsers as soon as we refresh.</p>
<h4 id="see-it-straight-away">See it straight away</h4>
<p>One last thing: while we're working on things, let's just have our browser auto-refresh the page.</p>
<p>We'll put this in the <code>&lt;head&gt;</code> of our HTML:</p>
<pre><code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;5&quot; &gt;</code></pre>
<p>So our final make step now looks like this:</p>
<pre><code>blog.html : $(blog_objects) 
    echo &#39;&lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot; &gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;2&quot; &gt;&lt;/head&gt;&lt;body&gt;&#39; &gt; blog.html 
    cat $(blog_objects) &gt;&gt; blog.html 
    echo &#39;&lt;/body&gt;&lt;/html&gt;&#39; &gt;&gt; blog.html</code></pre>
<p>Now, nobody like pages that auto-refresh while they're looking at them, so I'd like to take this out before pushing anything up, but there are a couple of things that mean it wouldn't be <em>the worst thing ever</em> if we forget:</p>
<ul>
<li>It looks like (Firefox at least) it nice enough to maintain your postion on the page between refreshes</li>
<li>Because we're generating a static page (that github's going to server statically), every request should actually hit the cache (unless there's been a real change), so it won't put as much extra load on the network/server as you might expect.</li>
</ul>
<p>Which is kind of nice...</p>
<h3 id="move-our-compilation-into-a-script">Move our compilation into a script</h3>
<p>I don't like writing raw bash (or makefiles, for that matter) any more than the next person. Let's move our bash step into a separate script:</p>
<pre><code>blog.html : $(blog_objects)
    ./compile_blog $(blog_objects)

--- ./compile_blog ---
#! /usr/bin/env sh
echo &#39;&lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot; &gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;2&quot; &gt;&lt;/head&gt;&lt;body&gt;&#39; &gt; blog.html 
cat $@ &gt;&gt; blog.html 
echo &#39;&lt;/body&gt;&lt;/html&gt;&#39; &gt;&gt; blog.html</code></pre>
<p>Phew. That's better. Okay, now let's move to using a nicer language than <code>sh</code> for manipulating files. We'll use python, since that's what I like.</p>
<pre><code>#! /usr/bin/env python3

import argparse
import sys

def parse_args(args):
    parser = argparse.ArgumentParser(description=&#39;Combine blog posts into a single page&#39;)
    parser.add_argument(&#39;output_file&#39;, type=argparse.FileType(&#39;w&#39;))
    parser.add_argument(&#39;input_files&#39;, nargs=argparse.REMAINDER)

    args = parser.parse_args(sys.argv[1:])
    return args.output_file, args.input_files


if __name__ == &#39;__main__&#39;:
    output_file, input_files = parse_args(sys.argv[1:])
        
    output_file.write(&#39;&lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot; &gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;2&quot; &gt;&lt;/head&gt;&lt;body&gt;&#39;)

    for entry_path in input_files:
        with open(entry_path, &#39;r&#39;) as blog_entry:
            output_file.write(blog_entry.read())

    output_file.write(&#39;&lt;/body&gt;&lt;/html&gt;&#39;)</code></pre>
<p>Finally, let's make it so that our main page re-compiles any time we make changes to its build script:</p>
<pre><code>blog.html : $(blog_objects) compile_blog
    ...</code></pre>
<h3 id="ordering-our-blog-posts">Ordering our blog posts</h3>
<p>Now we're in proper programming land, we can start to be more sophisticated with how we work with our files.</p>
<p>Let's start by moving them into some sort of very basic domain model:</p>
<pre><code>class BlogPost():
    def __init__(self, file_path):
        self.file_path = file_path

    def content(self):
        with open(self.file_path, &#39;r&#39;) as f:
            return f.read()

def compile(output_file, blog_posts):
    output_file.write(&#39;&lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot; &gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;2&quot; &gt;&lt;/head&gt;&lt;body&gt;&#39;)

    for b in blog_posts:
        output_file.write(b.content())

    output_file.write(&#39;&lt;/body&gt;&lt;/html&gt;&#39;)

def compile_files(output_file, input_paths):
    compile(output_file, (BlogPost(p) for p in input_paths))

if __name__ == &#39;__main__&#39;:
    compile_files(*parse_args(sys.argv[1:]))</code></pre>
<p>Now we've got a model, we can sort the blog posts by the details - in this case, I want the time the file was create (or, added to git, as a reasonable proxy, since I want it to survive renamed, checkouts elsewhere, that sort of thing).</p>
<pre><code>import subprocess
import datetime
import timezone


class BlogPost():
    ...
    def timestamp(self):
        timestamp = subprocess.check_output([&#39;git&#39;, &#39;log&#39;, &#39;--diff-filter=A&#39;, &#39;--pretty=%aD&#39; , &#39;--&#39;, self.file_path]).decode().strip()
        return datetime.strptime(timestamp, &#39;%a, %d %b %Y %H:%M:%S %z&#39;) if timestamp \
            else datetime.now(tz=timezone.utc) # if the file&#39;s not yet in git

...

def compile(...):
    ...
    for b in reversed(sorted(blog_posts, key=lambda b: b.timestamp())):
        ...</code></pre>
<p>Finally, let's put something around each post, so it's easier to see when one post stops and the next one starts:</p>
<pre><code>def compile(...):
    ...
    for b in ...
        output_file.write(&#39;&lt;section class=&quot;blog_post&quot;&gt;&#39;)
        output_file.write(b.content())
        output_file.write(&#39;&lt;/section&gt;&#39;)</code></pre>
<p>And we'll put something in <code>style.css</code> to make that visible:</p>
<pre><code>section.blog_post {
    border-top: 1px solid grey;
}</code></pre>
</section><section class="blog_post"><h2 id="building-a-static-blog-with-markdown-make-and-python">Building a static blog with Markdown, Make, and Python</h2>
<h3 id="background">Background</h3>
<p>I wanted to build a simple way to publish blog posts. I'm happy without any server-side gubbins; all I want it a simple place to put some static content, so github-pages is fine.</p>
<p>The other must for me is to be able to use markdown to write in. I've tried just doing raw HTML in the past, and frankly it doesn't fill me with joy.</p>
<p>Github has a tool built in, which you can install locally and test out - <a href="https://help.github.com/articles/using-jekyll-with-pages/">Jekyll</a> - but I wanted to use pandoc for compiling my markdown to HTML, and besides I don't have ruby installed.</p>
<h3 id="managing-the-build">Managing the build</h3>
<p>All the build needs to do is:</p>
<ul>
<li>figure out all the markdown files</li>
<li>convert them into HTML</li>
<li>compile that list into a single front-page blog.html</li>
</ul>
<p>Sounds like a job for make. Besides, that gives me a chance to brush up on Makefiles.</p>
<p>The rest of ths post goes through each of those steps, one by one. For reference, this whole site is checked in as a github page; you can easily check out the source for yourself <a href="https://github.com/jelford/jelford.github.io">here</a>.</p>
<h3 id="gathering-the-markdown-files">Gathering the markdown files</h3>
<p>Make has built-in macros for grouping together a series of files from one place into a build target:</p>
<pre><code>blog_sources := $(wildcard blog/*.md)
blog_outputs := $(patsubst %.md,%.html,$(blog_sources))</code></pre>
<p>Those will translate to something like:</p>
<pre><code>blog_sources := page_1.md this_blogpost.md that_blogpost.md
blog_outputs := page_1.html this_blogpost.html that_blogpost.html</code></pre>
<p>Using these macros, we can define a set of make rules to compile the blog pages, and then generate a single front-page that combines them together for easy browsing:</p>
<pre><code>blog.html : $(blog_outputs)
    combine_pages $(blog_outputs)

$(blog_outputs) : $(blog_sources)
    convert_to_html $&lt; $@</code></pre>
<p>So then we just have to implement the conversion and combining steps.</p>
<h3 id="converting-to-html">Converting to HTML</h3>
<p>I'll be using pandoc to convert markdown files to HTML. This couldn't be eaiser:</p>
<pre><code>blog/%.html : blog/%.md 
    pandoc --email-obfuscation=javascript $&lt; -f markdown -t html5 -o $@</code></pre>
<p>Notice this doesn't use <code>$(blog_outputs)</code> or <code>$(blog_sources)</code>. I found make was desperate to do <em>all</em> the <code>$(blog_outputs)</code> at once in the case they were the make target (makes sense), so this is a <a href="http://www.gnu.org/software/make/manual/make.html#Pattern-Intro">pattern rule</a>.</p>
<h3 id="combining">Combining</h3>
<p>Here's the simplest implementation I can think of for creating an easy-to-browse front page from all the inputs:</p>
<pre><code>blog.html : $(blog_objects)
    echo &#39;&lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot; &gt;&lt;/head&gt;&lt;body&gt;&#39; &gt; blog.html
    cat $(blog_objects) &gt;&gt; blog.html
    echo &#39;&lt;/body&gt;&lt;/html&gt;&#39; &gt;&gt; blog.html</code></pre>
<p>That'll just concatenate all the pages together (in any old order) into one long page with all the content. Pretty spartan, but it does the job. Just one more thing so we don't all hate ourselves every time we load the page: adding a style sheet:</p>
<pre><code>blog.html : $(blog_outputs)
    echo &#39;&lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot; &gt;&lt;/head&gt;&lt;body&gt;&#39; &gt; blog.html
    cat $(blog_objects) &gt;&gt; blog.html
    echo &#39;&lt;/body&gt;&lt;/html&gt;&#39; &gt;&gt; blog.html</code></pre>
<p>Over the course of the next few blog posts, I'll about adding nicities on top of this starting point:</p>
<ul>
<li>moving the combination step out of make into a script</li>
<li>ordering the posts by some sort of date</li>
<li>making the page load dynamically, so you don't just get everything on there as a one-er each time</li>
</ul>
</section></body></html>